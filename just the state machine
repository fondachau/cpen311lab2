
/*
.CLK_50M(CLK_50M),//input
.audiodata(audiodata),//output
.flash_mem_readdata(flash_mem_readdata),//input
.flash_mem_readdatavalid(flash_mem_readdatavalid),//input
.reset(reset),//input
.state(state),//output
//output logic [22:0] currentaddress,
//output logic [22:0] nextaddress,
.newclock1(newclock1),//input
.flash_mem_byteenable(flash_mem_byteenable),
.flash_mem_read(flash_mem_read)//output logic [31:0] d1,
//input logic resetcounter1
*/


module flash_fsm(
input logic CLK_50M,
output logic [15:0] audiodata,
input logic [31:0] flash_mem_readdata,
input logic flash_mem_readdatavalid,
input logic reset,
output logic [6:0] state,
//output logic [22:0] currentaddress,
//output logic [22:0] nextaddress,
input logic newclock1,
output flash_mem_read,
output flash_mem_byteenable
//output logic [31:0] d1,
//input logic resetcounter1
);
parameter [6:0] start = 7'b000_0000;
parameter [6:0] read = 7'b010_0000;
parameter [6:0] waitread = 7'b110_1111;
parameter [6:0] play1 = 7'b101_1111;
parameter [6:0] play2 = 7'b111_1111;


always_ff @ (posedge CLK_50M, posedge reset)
	begin
	if (reset) state<=start;
	else 
		begin
		case(state)
		start: begin
			state<=read;
	
			end
		read:begin
			state<=waitread;
			end
		waitread:begin
			if ( flash_mem_readdatavalid==1'b1) state<= play1;

			end
		play1:begin 
		if(newclock1) begin
			audiodata<= flash_mem_readdata [15:0];
			state<=play2;
			end
			else
			begin
			audiodata<= flash_mem_readdata [15:0];
			//LED[7:0]=8'b11111111;
			end
		end
		play2:
			begin 
			if(!newclock1) begin
			state<=start;
			audiodata<= flash_mem_readdata [31:16];
			end
		else 
		begin
			audiodata<= flash_mem_readdata [31:16];
			//LED[7:0]=8'b00000000;
			end
			end
		default: state<=start;
		
		endcase
end//end else 
		end//end alwaysff

assign flash_mem_read=~state[4];
assign flash_mem_byteenable={~state[3],~state[2],~state[1],~state[0]};


endmodule 
